# grafana_api.py
# Grafana API integration for creating dashboards from AI analysis

import json
import requests
import logging
from typing import Dict, List, Optional, Any
from datetime import datetime, timedelta

logger = logging.getLogger(__name__)

class GrafanaAPI:
    """Grafana API client for creating and managing dashboards"""
    
    def __init__(self, grafana_url: str = "http://52.4.166.16:3000", api_key: str = None):
        self.grafana_url = grafana_url.rstrip('/')
        self.api_key = api_key or "admin:admin"  # Basic auth fallback
        self.session = requests.Session()
        
        # Set up authentication
        if api_key and api_key.startswith('eyJ'):  # JWT token
            self.session.headers.update({
                'Authorization': f'Bearer {api_key}',
                'Content-Type': 'application/json'
            })
        else:
            # Use basic auth (admin:admin)
            self.session.auth = ('admin', 'admin')
            self.session.headers.update({'Content-Type': 'application/json'})
    
    def create_dashboard_from_analysis(self, analysis: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """Create a Grafana dashboard from AI analysis"""
        try:
            # Generate dashboard configuration
            dashboard_config = self._build_dashboard_config(analysis, user_id)
            
            # Create the dashboard
            response = self.session.post(
                f"{self.grafana_url}/api/dashboards/db",
                json=dashboard_config,
                timeout=30
            )
            
            if response.status_code == 200:
                result = response.json()
                dashboard_uid = result['uid']
                dashboard_id = result['id']
                
                # Get the main panel ID (usually 1 for single-panel dashboards)
                panel_id = 1
                
                return {
                    'success': True,
                    'dashboard_uid': dashboard_uid,
                    'dashboard_id': dashboard_id,
                    'dashboard_url': f"{self.grafana_url}/d/{dashboard_uid}",
                    'embed_url': f"{self.grafana_url}/d-solo/{dashboard_uid}",
                    'panel_embed_url': f"{self.grafana_url}/d-solo/{dashboard_uid}?panelId={panel_id}&refresh=30s",
                    'panel_id': panel_id
                }
            else:
                logger.error(f"Grafana API error: {response.status_code} - {response.text}")
                return {
                    'success': False,
                    'error': f"Grafana API error: {response.status_code}",
                    'details': response.text
                }
                
        except Exception as e:
            logger.error(f"Error creating Grafana dashboard: {e}")
            return {
                'success': False,
                'error': str(e)
            }
    
    def _build_dashboard_config(self, analysis: Dict[str, Any], user_id: int) -> Dict[str, Any]:
        """Build Grafana dashboard configuration from AI analysis"""
        
        title = analysis.get('title', 'AI Generated Dashboard')
        description = analysis.get('description', 'Generated by AI from user request')
        
        # Create the main panel
        panel = self._create_panel_from_analysis(analysis)
        
        dashboard_config = {
            "dashboard": {
                "id": None,
                "title": title,
                "description": description,
                "tags": ["ai-generated", f"user-{user_id}", "ercot"],
                "timezone": "browser",
                "panels": [panel],
                "time": self._get_time_range(analysis.get('time_range', '24h')),
                "refresh": "30s",
                "schemaVersion": 30,
                "version": 0,
                "links": [],
                "annotations": {
                    "list": []
                },
                "templating": {
                    "list": []
                }
            },
            "folderId": 0,
            "overwrite": False,
            "message": f"Created by AI for user {user_id}"
        }
        
        return dashboard_config
    
    def _create_panel_from_analysis(self, analysis: Dict[str, Any]) -> Dict[str, Any]:
        """Create a Grafana panel from AI analysis"""
        
        chart_type = analysis.get('chart_type', 'line')
        title = analysis.get('title', 'Data Visualization')
        sql_query = analysis.get('sql_query', '')
        
        # Map chart types to Grafana panel types
        panel_type_mapping = {
            'line': 'timeseries',
            'bar': 'barchart', 
            'table': 'table',
            'stat': 'stat',
            'gauge': 'gauge'
        }
        
        panel_type = panel_type_mapping.get(chart_type, 'timeseries')
        
        panel = {
            "id": 1,
            "title": title,
            "type": panel_type,
            "gridPos": {
                "h": 12,
                "w": 24,
                "x": 0,
                "y": 0
            },
            "targets": [
                {
                    "datasource": {
                        "type": "postgres",
                        "uid": "postgres_datasource"  # You'll need to configure this in Grafana
                    },
                    "format": "time_series",
                    "group": [],
                    "metricColumn": "none",
                    "rawQuery": True,
                    "rawSql": sql_query,
                    "refId": "A",
                    "select": [
                        [
                            {
                                "params": ["value"],
                                "type": "column"
                            }
                        ]
                    ],
                    "timeColumn": "timestamp",
                    "where": [
                        {
                            "name": "$__timeFilter",
                            "params": [],
                            "type": "macro"
                        }
                    ]
                }
            ],
            "options": self._get_panel_options(panel_type),
            "fieldConfig": {
                "defaults": {
                    "color": {
                        "mode": "palette-classic"
                    },
                    "custom": {},
                    "mappings": [],
                    "thresholds": {
                        "mode": "absolute",
                        "steps": [
                            {
                                "color": "green",
                                "value": None
                            }
                        ]
                    },
                    "unit": "short"
                },
                "overrides": []
            }
        }
        
        return panel
    
    def _get_panel_options(self, panel_type: str) -> Dict[str, Any]:
        """Get panel-specific options"""
        
        options = {
            'timeseries': {
                "tooltip": {
                    "mode": "single",
                    "sort": "none"
                },
                "legend": {
                    "displayMode": "visible",
                    "placement": "bottom"
                }
            },
            'barchart': {
                "orientation": "auto",
                "groupWidth": 0.7,
                "barWidth": 0.97
            },
            'table': {
                "showHeader": True
            },
            'stat': {
                "reduceOptions": {
                    "values": False,
                    "calcs": ["lastNotNull"],
                    "fields": ""
                },
                "textMode": "auto",
                "colorMode": "value"
            }
        }
        
        return options.get(panel_type, {})
    
    def _get_time_range(self, time_range: str) -> Dict[str, str]:
        """Convert time range to Grafana format"""
        
        time_mappings = {
            '1h': {"from": "now-1h", "to": "now"},
            '6h': {"from": "now-6h", "to": "now"},
            '24h': {"from": "now-24h", "to": "now"},
            '7d': {"from": "now-7d", "to": "now"},
            '30d': {"from": "now-30d", "to": "now"}
        }
        
        return time_mappings.get(time_range, time_mappings['24h'])
    
    def test_connection(self) -> Dict[str, Any]:
        """Test connection to Grafana"""
        try:
            response = self.session.get(f"{self.grafana_url}/api/org", timeout=10)
            
            if response.status_code == 200:
                org_info = response.json()
                return {
                    'success': True,
                    'message': f"Connected to Grafana - Organization: {org_info['name']}",
                    'org_info': org_info
                }
            else:
                return {
                    'success': False,
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }
    
    def delete_dashboard(self, dashboard_uid: str) -> Dict[str, Any]:
        """Delete a dashboard by UID"""
        try:
            response = self.session.delete(
                f"{self.grafana_url}/api/dashboards/uid/{dashboard_uid}",
                timeout=10
            )
            
            if response.status_code == 200:
                return {'success': True, 'message': 'Dashboard deleted successfully'}
            else:
                return {
                    'success': False,
                    'error': f"HTTP {response.status_code}: {response.text}"
                }
                
        except Exception as e:
            return {
                'success': False,
                'error': str(e)
            }

# Helper function to create Grafana API instance
def get_grafana_api() -> GrafanaAPI:
    """Get a configured Grafana API instance"""
    return GrafanaAPI(
        grafana_url="http://52.4.166.16:3000",
        api_key=None  # Will use admin:admin basic auth
    )
